#### 进程地址空间和虚拟存储空间
在早期的计算机中，如果要运行一个程序，需要把这个程序全部装入内存，程序是直接运行在内存上的，也就是**程序中访问的内存地址就是实际的物理内存地址**当计算机同时运行多个程序时，就必须要保证这些程序所用到的内存总量要小于计算机实际物理内存的大小。例如：  
某台计算机内存总大小为128MB， 现在要同时运行两个程序A和B  
![](http://p.blog.csdn.net/images/p_blog_csdn_net/do2jiang/EntryImages/20091017/1.JPG)
这样的分配策略缺点如下：  
1、进程地址空间不隔离，由于程序都是直接访问物理内存，所以恶意程序可以随意修改别的进程的内存数据，或者有些bug程序不小心修改了其他程序的内存数据。这种情况无法容忍，因为用户希望使用计算机时，其中一个任务失败了，至少不能影响其他任务。  
2、内存使用效率低下。如果要运行需要20MB内存大小的程序C，就需要释放其中一个进程才行。  
3、程序运行的地址不确定，当内存中的剩余空间可以满足程序C的要求后，operator system会在剩余空间随机分配一段连续的20MB大小的空间给程序C使用，因为是随机分配的，所以程序运行的地址是不确定的。  

**为了解决上述问题，人们想到了一个变通的方法，就是增加一个中间层，利用一种间接的地址访问方法访问物理内存。这时候程序中访问的内存地址不再是实际的物理内存地址，而是一个虚拟地址，然后由operator system将这个虚拟地址映射到适当的物理内存地址上。**只要operator system处理好虚拟地址到物理内存地址的映射，就可以保证不同程序最终访问的内存地址位于不同的区域。  
所以创建虚拟空间的目的是**为了解决进程地址空间隔离的问题**  
######例子
当创建一个进程时，operator system会为该进程分配一个4GB大小的虚拟进程地址空间，之所以是4GB，是因为32位的operator system，一个指针的长度为4字节，与虚拟地址空间相对的还有一个物理地址空间，这个地址空间对应的是真实的物理内存，若你的计算机上安装了512MB大小的内存，则operator system做虚拟地址到物理地址的映射时，只能映射到这一范围，当进程创建时，每个进程都会有一个自己的4GB虚拟地址空间，这个4GB的地址空间是虚拟的，并不是真实存在的，并且每个进程只能访问自己虚拟地址空间中的数据，无法访问别的进程中的数据。通过这种方法实现了地址隔离。  


在Linux中，[内核把虚拟地址空间分为两个部分](http://blog.csdn.net/iter_zc/article/details/42644229)：用户进程空间和内核进程空间，
![](http://img.blog.csdn.net/20150112163706063?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSVRlcl9aQw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)  

###### 虚拟内存的优点
* 给所有进程提供一致的地址空间，每个进程都认为自己是在独占使用单机系统的存储资源
* 保护每个进程的地址空间不被其他进程破坏隔离了进程的地址访问  
* 根据缓存原理，上层存储是下层存储的缓存，虚拟内存把主存作为磁盘的高速缓存，在主存和磁盘之间根据需要来回传送数据，高效使用了主存。
