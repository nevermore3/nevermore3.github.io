##### 为什么使用const？  
	 采用符号常量写出的代码更容易维护，指针常常是边读边移动的，而不是边写边移动的，并且许多函数参数是只读不写的，
	 对于常量来说，系统没有划定专门的区域来保护其中的数据不能被更改，也就是说，使用常量的方式对数据进行保护是通过编译器作语法限制来实现的。
##### [常见的const分类](http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777416.html)
* 常变量： const 类型说明符  变量名
* 常引用： const 类型说明符  &引用名
* 常对象： 类名 const 对象名
* 常成员函数： 类名::fun(形参) const
* 常数组： 类型说明符 const 数组名[大小]
* 常指针： const 类型说明符* 指针名   或者   类型说明符* const 指针名

##### 用法1：常量

取代了C中的宏定义，声明的时候必须初始化(和引用一样)，C++类则不然，const声明的变量可以保证类型安全

##### 用法2： 指针和常量

使用指针时涉及两个对象，该指针本身和被它所指向的对象，出现在 * 之前的const是作为基础类型的一部分，例如

	char *const cp; //到char的const指针
	char const *pc1;  //到const char 的指针
	const char *pc2； //到const char 的指针
可以遵循从右向左读的记忆方式  

 **允许把非const对象的地址赋给指向const对象的指针，但是不允许把const 对象的地址赋给一个普通的、非const对象的指针**

##### 用法3： 用const修饰函数入参
将函数入参声明为const，是为了让调用函数不能修改对象的值，是为了效率和安全原因。

##### 用法4： const修饰成员函数（C++特性）

* const对象只能访问const成员函数， 非const对象可以访问任意成员函数包括const成员函数
* const对象的成员是不能被修改的，而通过指针维护的对象确实可以修改
* const成员函数不可以修改对象的数据，不管对象是否具有const性质。

**其特性是通过每个函数都有this指针实现的， const成员函数的this指针是常量指针，而非const成员函数的this指针是非常量指针**
