#### 正常通过read或write函数的流程

从代码层面上看，从硬盘上将文件读入内存，都要经过文件系统进行数据拷贝，并且数据拷贝操作是由文件系统和硬件驱动实现的，


![](http://hi.csdn.net/attachment/201009/17/0_1284702221pRyi.gif)

下面分析read或write的几个过程：

* 首先将文件内容从硬盘拷贝到内核空间的一个缓冲区，如图过程1所示
* 将这些数据从内核空间拷贝到用户空间，如果过程2所示








#### [内存映射原理](https://security.tencent.com/index.php/blog/msg/38)

首先，“映射”这个词，就和数学课上说的“--映射”是一个意思，就是建立一种一一对应的关系，在这里主要是指 **硬盘文件** 的位置与进程 **逻辑地址空间** 中一块大小相同的区域之间的一一对应， 如下图所示。这种对应关系纯属逻辑上的概念，物理上是不存在的。原因是进程的逻辑地址空间本身就是不存在的。在内存映射的过程中，并没有实际的数据拷贝产生，并且文件也没有被载入内存中，只是**逻辑上**被放入了内存，具体到代码层面，就是建立并初始化了**相关的数据结构** ，这个过程有系统调用mmap()函数实现（mmap函数主要就是建立一些数据结构），因此针对大文件，建立内存映射的效率很高。
![](http://hi.csdn.net/attachment/201009/17/0_1284702135HcPp.gif)

下面分析内存映射的几个过程：

* mmap()会返回一个指针ptr，它指向进程逻辑地址空间中的一个地址，这样进程无需在调用read或者write对文件进行读写，而只需要通过ptr就能够操作文件，但是ptr指向的是一个逻辑地址，要操作其中的数据，必须通过[MMU](https://blog.csdn.net/ipmux/article/details/19167605)将逻辑地址转换成物理地址。这个过程和内存映射无关。

* 由于内存映射没有实际数据拷贝发生，因此MMU在地址映射表中是无法找到与ptr相对应的物理地址。也就是MMU会失败，将产生一个缺页中断，缺页中断的中断响应函数会在swap中寻找相对应的页面，如果找不到(该文件从来没有被读入内存)则会通过mmap建立映射关系，从硬盘上将文件读取到物理内存中。如过程3， 这个过程与内存映射无关。

* 如果在拷贝数据过程中，发现物理内存不够用，则会通过虚拟内存机制(swap)将暂时不用的物理页面交换到硬盘上，如过程4所示，这个过程与内存映射无关。



通过对比分析通过read或write函数调用进行了两次数据拷贝，而mmap()也是系统调用，如前所述，mmap()中没有进行数据拷贝，真正的数据拷贝是在缺页中断处理时进行的，由于mmap()将文件直接映射到用户空间，所以中断处理函数根据这个映射关系，直接将文件从硬盘拷贝到用户空间，只进行了 一次数据拷贝 。因此，内存映射的效率要比read/write效率高。
