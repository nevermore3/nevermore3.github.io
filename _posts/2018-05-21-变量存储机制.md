### 变量存储机制
1、机器语言  

机器语言是机器指令的集合。电子计算机的机器指令是一列二进制数字，而计算机将之转变为一列高低电平，使计算机的电子器件受到驱动，进行运算。例如8086的CPU完成运算`s = 768 + 12288 - 1280`机器码如下：  

	101100000000000000000011
	000001010000000000110000
	001011010000000000000101
其中没一行代表一个指令。关于变量名：机器语言中没有变量名的概念，一切操作都是直接对地址进行。

2、汇编语言  
由于机器语言难于辨认和记忆，汇编语言诞生了，汇编语言和机器语言是每个指令是一一对应的，最终由汇编器把汇编代码编译成可执行程序。例如将寄存器BX内的数据移动到AX中。  

	机器指令：1000100111011000
	汇编指令：mov ax,bx
寄存器是CPU内部的一组存储器，大多数汇编指令都需要先将内存的数据读入到寄存器后才能开始运算。
关于变量名：汇编语言中有变量的概念，在编译时由汇编器计算相关变量的偏移或者实际地址，在编译出的二进制机器语言中直接使用该地址操作内存。

3、C语言  
后来发现使用汇编语言写程序还是麻烦，因为它和机器指令意义对应，接近CPU的思维不是人的思维，于是发明了C语言。C语言编译的过程实际上是通过编译器将C语言编译成汇编语言，然后再通过汇编器将汇编语言转化为机器代码。  
关于变量名：C语言中处处是变量。即使是个指针，它本身也是个4字节的变量才能存储一个地址。C程序代码编译后有两种文件：  

1. 可执行文件，一段二进制文件，其中代码段的机器指令CPU可以直接识别
2. 符号文件(XXX.pdb),记录了变量和地址的对应信息，仅供调试使用。

#### 变量名存储在哪里？
1. 程序运行时不需要知道某块内存对应的变量名，它只是按照地址直接操作那块内存
2. C&C++编译器在编译时会计算出变量名对应的地址，在底层所有操作该变量的地方，都使用变量对应的地址参与运算。

`int  a = 4` 对于编译器，它会搜集我们的变量名，为程序预留4个字节的空间，并把变量名'a'保存进符号表，并用这个符号表的索引对应实际的空间。如果出现`b = a `则编译器会根据符号表找到变量的真正物理地址，取得它的值，然后赋给b。  
因此a是我们对那个整形变量的4个字节取的"名字",
是我们人为给的,实际上计算机并不存储a这个名字,只是我们编程时给那4个字节内存取个名字好用.实际上程序在编译时,所有的a都转换为了那个地址空间了.编译成机器代码后,没有a这个说法了.a这个名字只存在于我们编写的代码中.


总结：变量名是给编译器看的，编译器根据变量是局部还是全局分配内存地址或栈空间，所谓变量名在内存中不存在，操作时转换成地址数存放在寄存器中。
编译器会将合法的变量名放到一个叫“符号表”的表中，每个符号对应一个地址，当你调用此变量的时，就会根据此符号表找到对应的地址，然后进行操作。


#### [C&C++函数的返回值存在哪里](https://blog.csdn.net/natsu1211/article/details/8558163)
返回值保存在一段临时区域（寄存器中）到下一条语句时，返回值被销毁，所以如果要继续使用返回值，必须将返回值赋予其他变量。  
不大于32位的返回值在EAX中。64位的在EDX+EAX中，如果再大就要传指针了。  
如果是结构体类型的话怎么办，因为struct类型可大可小，无法存放到寄存器中。答案是：主调函数会把被赋值对象的地址传给被调函数

总结： [函数的调用环节可以分为如下](https://blog.csdn.net/chance_yin/article/details/21191285)：



1.  传参
2.  保存上下文
3.  向返回值空间写值
4.  恢复上下文
5.  从临时空间拷贝数据
