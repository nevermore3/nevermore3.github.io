1、机器语言  

机器语言是机器指令的集合。电子计算机的机器指令是一列二进制数字，而计算机将之转变为一列高低电平，使计算机的电子器件受到驱动，进行运算。例如8086的CPU完成运算`s = 768 + 12288 - 1280`机器码如下：  

	101100000000000000000011
	000001010000000000110000
	001011010000000000000101
	
其中没一行代表一个指令。关于变量名：机器语言中没有变量名的概念，一切操作都是直接对地址进行。

2、汇编语言  
由于机器语言难于辨认和记忆，汇编语言诞生了，汇编语言和机器语言是每个指令是一一对应的，最终由汇编器把汇编代码编译成可执行程序。例如将寄存器BX内的数据移动到AX中。  

	机器指令：1000100111011000
	汇编指令：mov ax,bx
	
寄存器是CPU内部的一组存储器，大多数汇编指令都需要先将内存的数据读入到寄存器后才能开始运算。
关于变量名：汇编语言中有变量的概念，在编译时由汇编器计算相关变量的偏移或者实际地址，在编译出的二进制机器语言中直接使用该地址操作内存。

3、C语言  
后来发现使用汇编语言写程序还是麻烦，因为它和机器指令意义对应，接近CPU的思维不是人的思维，于是发明了C语言。C语言编译的过程实际上是通过编译器将C语言编译成汇编语言，然后再通过汇编器将汇编语言转化为机器代码。  
关于变量名：C语言中处处是变量。即使是个指针，它本身也是个4字节的变量才能存储一个地址。C程序代码编译后有两种文件：  

1. 可执行文件，一段二进制文件，其中代码段的机器指令CPU可以直接识别
2. 符号文件(XXX.pdb),记录了变量和地址的对应信息，仅供调试使用。

#### 变量名存储在哪里？
1. 程序运行时不需要知道某块内存对应的变量名，它只是按照地址直接操作那块内存
2. C&C++编译器在编译时会计算出变量名对应的地址，在底层所有操作该变量的地方，都使用变量对应的地址参与运算。

`int  a = 4` 对于编译器，它会搜集我们的变量名，为程序预留4个字节的空间，并把变量名'a'保存进符号表，并用这个符号表的索引对应实际的空间。如果出现`b = a `则编译器会根据符号表找到变量的真正物理地址，取得它的值，然后赋给b。  
因此a是我们对那个整形变量的4个字节取的"名字",
是我们人为给的,实际上计算机并不存储a这个名字,只是我们编程时给那4个字节内存取个名字好用.实际上程序在编译时,所有的a都转换为了那个地址空间了.编译成机器代码后,没有a这个说法了.a这个名字只存在于我们编写的代码中.


总结：变量名是给编译器看的，编译器根据变量是局部还是全局分配内存地址或栈空间，所谓变量名在内存中不存在，操作时转换成地址数存放在寄存器中。
编译器会将合法的变量名放到一个叫“符号表”的表中，每个符号对应一个地址，当你调用此变量的时，就会根据此符号表找到对应的地址，然后进行操作。


#### [C&C++函数的返回值存在哪里](https://blog.csdn.net/natsu1211/article/details/8558163)

返回值保存在一段临时区域（寄存器中）到下一条语句时，返回值被销毁，所以如果要继续使用返回值，必须将返回值赋予其他变量。  
一般情况下，寄存器EAX是传递返回值的通道，被调函数将返回值存储在EAX中，返回后主调函数再读取EAX。但是EAX本身只有4个字节，不大于32位的返回值在EAX中。64位的在EDX+EAX中，如果再大就要传指针了。   

 
如果是结构体类型的话怎么办，因为struct类型可大可小，无法存放到寄存器中。答案是：[主调函数会把被赋值对象的地址传给被调函数](https://blog.csdn.net/yang_yulei/article/details/45795591)  

	typedef struct big_thing
	{
		char buf[128];
	}big_thing;
	big_thing return_test();
	int main()
	{
		big_thing n = return_test();
	}

	big_thing return_test()
	{
		big_thing b;
		b.buf[0] = 0;
		return b;
	}
首先，在主调函数main中，肯定有一个128字节的变量n，在被调函数return\_test中也有一个128字节的变量b存在。  

那么被调函数如何返回128字节的变量？ 直接从b拷贝到n么？ 如果这样的话就直接改变了主调函数中变量的值，不符合返回值的传值原则。  

实际上，编译器针对大尺寸返回值传递如下：  

1. 主调函数在其栈中的局部变量区域**额外开辟一片空间**，将其一部分作为传递返回值的临时对象temp。
2. 将temp对象的地址作为**隐藏参数**传递给return_test函数(针对类成员函数this指针的传递)
3. 被调函数将数据拷贝给temp对象，**并将temp对象的地址用EAX传出**
4. 被调函数返回后，主调函数将EAX指向的temp对象的内容拷贝给主调函数的变量  

![](https://img-blog.csdn.net/20150521234059218?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ195dWxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

总结： [函数的调用环节可以分为如下](https://blog.csdn.net/chance_yin/article/details/21191285)：



1.  传参
2.  保存上下文
3.  向返回值空间写值
4.  恢复上下文
5.  从临时空间拷贝数据

### 函数返回值传递可以涉及到(递归，移动语义，右值引用，智能指针，返回值优化等等)
