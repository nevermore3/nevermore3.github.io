由于在工作中经常遇到链接问题，因此特意花了一下午补充一下编译链接的知识，其中大部分是参考网上内容。

* 预处理：通过预处理的内建功能对一个资源进行等价替换，常见的预处理有：文件包含，条件编译，布局控制和宏替换。
* 编译： 编译器对源文件进行编译，就是把源文件中的文本形式存在的源代码翻译成机器语言形式的目标文件，在这个过程中，编译器会进行一系列的语法检查，如果编译通过，就会把cpp文件生成对应的obj文件。
* 编译单元： 每一个CPP文件就是一个编译单元，编译时，每一个编译单元互相独立并且互相不可见。
* 目标文件： 由编译所生成的文件，以机器码的形式包含了编译单元里所有的代码和数据，还有一些其他信息，如**未解决符号表**，**导出符号表**，**地址重定向表**等，目标文件是以二进制形式存在的。


在预编译的时候 .h头文件会被复制、、扩展到包含它的.cpp文件里，然后编译器编译该.cpp文件为一个.obj文件，该.cpp文件作为一个编译单元独立编译。当编译器将一个工程里的所有.cpp文件以分离的方式编译完毕后，再由链接器进行链接成为一个可执行文件

#### 编译器的工作过程

例如有一个A.cpp文件，定义如下：

	int n = 1;
	void FunA()
	{
		n++;
	}

则它编译出来的目标文件A.obj就有一个区域，包含数据n和函数FunA，如下：

	偏移量      内容     长度
	0x0000	    n        4
    0x0004     FunA      ??
FunA函数的内容可能如下：

	0x0004    inc   DWORD PTR[0x0000]
    0x00??    ret

有另外一个B.cpp文件，定义如下：

	extern int n;
	void FunB()
	{
		n++;
	}
对应B.obj的二进制可能如下：

	偏移量      内容     长度
	0x0000     FunB     ??
此时，由于n被声明为extern，而extern关键字告诉编译器n已经在别的编译单元里定义了，在这个单元里不用定义。由于编译单元之间是互不相关的，所以编译器就不知道n究竟在哪里，所以在函数FunB中就没有办法生成n的地址，那么函数FunB中就是这样的：

	0x0000    inc DWORD PTR[????]
    0x00??    ret
为了让各个编译单元结合起来，就需要链接器了。为了能让链接器知道哪些地方的地址没有填好（也就是还????），那么目标文件中就要有一个表来告诉链接器，这个表就是**未解决符号表(unresolved symbol table)**,同样，提供n的目标文件也要提供一个**导出符号表(exprot symbol table)**,来告诉链接器自己可以提供哪些地址.

那么这两个表示如何建立对应的关系呢？  

在C/C++中，每一个变量及函数都会有自己的符号，如变量n的符号就是n，函数的符号会更加复杂，根据编译器不同而不同。

A.obj的导出符号表为：

	符号		地址
	n		0x0000
	_FunA   0x0004

A.obj的未解决符号表为空。  


B.obj的导出符号表为：

	符号		地址
	_FunB	0x0000
B.obj的未解决符号表为：

	符号		地址
	n		0x0001
这个表告诉链接器，在本编译单元0x0001位置有一个地址，该地址不明，但符号是n。  

在链接的时候，链接器在B.obj中发现了未解决符号，就会在所有的编译单元中的**导出符号表**去查找与这个未解决符号相匹配的符号名，如果找到，就把这个符号的地址填到B.obj的未解决符号的地址处。如果没有找到，就会报链接错误。在此例中，在A.obj中会找到符号n，就会把n的地址填到B.obj的0x0001处。  

如果是这样的话，B.obj的函数FunB的内容就会变成：  

	inc DWORD　　PTR[0x0000]   #因为n在A.obj中的地址是0x0000

如果每个编译单元的地址都是从0x0000开始，那么最终多个目标文件链接时就会导致地址重复。所以链接器在链接时就会对每个目标文件的地址进行调整。比如B.obj的0x0000被定位到可执行文件的0x00001000上，而A.obj的0x0000被定位到可执行文件的0x00002000上，这样就可以保证地址不会重复。为实现这一点，目标文件还要提供一个表，叫**地址重定向表（address redirect table)**  

#### 总结
目标文件至少要提供三个表： 

* 未解决符号表 ：列出了本单元里有引用但是不在本单元定义的符号及其出现的地址
* 导出符号表 ：提供了本编译单元具有定义，并且可以提供给其他编译单元使用的符号及其在本单元中的地址
* 地址重定向表 ：提供了本编译单元所有对自身地址的引用记录。

当链接器进行链接的时候，首先决定各个目标文件在最终可执行文件里的位置。然后访问所有目标文件的地址重定义表，对其中记录的地址进行重定向（加上一个偏移量，即该编译单元在可执行文件上的起始地址）。然后遍历所有目标文件的未解决符号表，并且在所有的导出符号表里查找匹配的符号，并在未解决符号表中所记录的位置上填写实现地址。最后把所有的目标文件的内容写在各自的位置上，再作一些其他工作，就生成一个可执行文件。


#### C/C++针对这些提供的特性

* extern：告诉编译器，这个符号在别的编译单元里定义，也就是要把这个符号放到未解决符号表里去。（外部链接）
* static：如果该关键字位于全局函数或者变量的声明的前面，表明该编译单元不导出这个函数／变量的符号。因此无法在别的编译单元里使用。（内部链接）。如果是static局部变量，则该变量的存储方式和全局变量一样，但是仍然不导出符号。
